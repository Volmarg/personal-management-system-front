import{K as r}from"./index.5c1c3a9f.js";function e(r){return"function"==typeof r}function a(r){return null!==r&&"object"==typeof r&&!Array.isArray(r)}function t(r){return e(r.$validator)?Object.assign({},r):{$validator:r}}function n(r){return"object"==typeof r?r.$valid:r}function o(r){return r.$validator||r}const i=e=>{if(e=r(e),Array.isArray(e))return!!e.length;if(null==e)return!1;if(!1===e)return!0;if(e instanceof Date)return!isNaN(e.getTime());if("object"==typeof e){for(let r in e)return!0;return!1}return!!String(e).length};function s(e){return a=>(a=r(a),!i(a)||e.test(a))}var $=Object.freeze({__proto__:null,withParams:function(r,n){if(!a(r))throw new Error('[@vuelidate/validators]: First parameter to "withParams" should be an object, provided '+typeof r);if(!a(n)&&!e(n))throw new Error("[@vuelidate/validators]: Validator must be a function or object with $validator parameter");const o=t(n);return o.$params=Object.assign({},o.$params||{},r),o},withMessage:function(n,o){if(!e(n)&&"string"!=typeof r(n))throw new Error('[@vuelidate/validators]: First parameter to "withMessage" should be string or a function returning a string, provided '+typeof n);if(!a(o)&&!e(o))throw new Error("[@vuelidate/validators]: Validator must be a function or object with $validator parameter");const i=t(o);return i.$message=n,i},withAsync:function(r,e=[]){const a=t(r);return Object.assign({},a,{$async:!0,$watchTargets:e})},forEach:function(e){return{$validator(a,...t){return r(a).reduce(((r,a)=>{const i=Object.entries(a).reduce(((r,[a,i])=>{const s=e[a]||{},$=Object.entries(s).reduce(((r,[e,s])=>{const $=o(s).call(this,i,...t),u=n($);if(r.$data[e]=$,!u){let t=s.$message||"",n=s.$params||{};"function"==typeof t&&(t=t({$pending:!1,$invalid:!u,$params:n,$model:i,$response:$})),r.$errors.push({$property:a,$message:t,$params:n,$response:$,$model:i,$pending:!1,$validator:e})}return{$valid:r.$valid&&u,$data:r.$data,$errors:r.$errors}}),{$valid:!0,$data:{},$errors:[]});return r.$data[a]=$.$data,r.$errors[a]=$.$errors,{$valid:r.$valid&&$.$valid,$data:r.$data,$errors:r.$errors}}),{$valid:!0,$data:{},$errors:{}});return{$valid:r.$valid&&i.$valid,$data:r.$data.concat(i.$data),$errors:r.$errors.concat(i.$errors)}}),{$valid:!0,$data:[],$errors:[]})},$message:({$response:r})=>r?r.$errors.map((r=>Object.values(r).map((r=>r.map((r=>r.$message)))).reduce(((r,e)=>r.concat(e)),[]))):[]}},req:i,len:e=>(e=r(e),Array.isArray(e)?e.length:"object"==typeof e?Object.keys(e).length:String(e).length),regex:s,unwrap:r,unwrapNormalizedValidator:o,unwrapValidatorResponse:n,normalizeValidatorObject:t}),u={$validator:s(/^(?:[A-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[A-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9]{2,}(?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i),$message:"Value is not a valid email address",$params:{type:"email"}},d={$validator:function(r){return"string"==typeof r&&(r=r.trim()),i(r)},$message:"Value is required",$params:{type:"required"}};function l(e){return a=>r(a)===r(e)}function c(r,e="other"){return{$validator:l(r),$message:({$params:r})=>`The value must be equal to the ${e} value`,$params:{equalTo:r,otherName:e,type:"sameAs"}}}export{$ as c,u as e,d as r,c as s};
